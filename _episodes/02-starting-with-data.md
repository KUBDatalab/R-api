---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 02-starting-with-data.md in _episodes_rmd/
title: "Starting with Data"
teaching: 50
exercises: 30
questions:
- "What else have we forgotten about R?"
- "What is a data.frame?"
- "How can I read a complete csv file into R?"
- "How can I get basic summary information about my dataset?"
- "How can I change the way R treats strings in my dataset?"
- "Why would I want strings to be treated differently?"
- "How are dates represented in R and how can I change the format?"
objectives:
- "Describe what a data frame is."
- "Load external data from a .csv file into a data frame."
- "Summarize the contents of a data frame."
- "Subset and extract values from data frames."
- "Describe the difference between a factor and a string."
- "Convert between strings and factors."
- "Reorder and rename factors."
- "Change how character strings are handled in a data frame."
- "Examine and change date formats."
keypoints:
- "Use read_csv to read tabular data in R."
- "Use factors to represent categorical data in R."
source: Rmd
---

# no no no. You should also know this!
Two concepts of some importance working with the apis we are using as examples in this course, are not typically covered in our introductory courses to R.



~~~
library(tidyverse)
~~~
{: .language-r}


## Lists

Vectors can only contain one type of data.

But what if we want to have a data structure that can contain more than one 
type of data?

That data structure is called a list. 

Lists can contain any kind of data:


~~~
my_list <- list("a", 1, T)
my_list
~~~
{: .language-r}



~~~
[[1]]
[1] "a"

[[2]]
[1] 1

[[3]]
[1] TRUE
~~~
{: .output}
Even other lists, or dataframes:

~~~
my_complicated_list <- list(my_list, 47)
my_complicated_list
~~~
{: .language-r}



~~~
[[1]]
[[1]][[1]]
[1] "a"

[[1]][[2]]
[1] 1

[[1]][[3]]
[1] TRUE


[[2]]
[1] 47
~~~
{: .output}
We could even keep dataframes in lists, but that gets messy when we print it out.

From the output, we get an indication on how to subset elements from a list:


~~~
my_complicated_list[2]
~~~
{: .language-r}



~~~
[[1]]
[1] 47
~~~
{: .output}
The result is a list, if we want to get the content of this list element, we
use double brackets:

~~~
my_complicated_list[[2]]
~~~
{: .language-r}



~~~
[1] 47
~~~
{: .output}
Elements of a list can be named:

~~~
my_named_list <- list("number" = 1, "charachter" = "a", "list" = my_list)
my_named_list
~~~
{: .language-r}



~~~
$number
[1] 1

$charachter
[1] "a"

$list
$list[[1]]
[1] "a"

$list[[2]]
[1] 1

$list[[3]]
[1] TRUE
~~~
{: .output}

Now we can subset the list using names:

~~~
my_named_list$charachter
~~~
{: .language-r}



~~~
[1] "a"
~~~
{: .output}

The structure of lists make them cumbersome to work with, but for some purposes they are,
as we shall see, very useful!

## Formatting Dates

One of the most common issues that new (and experienced!) R users have is
converting date and time information into a variable that is appropriate and
usable during analyses. 

We (plan to) run an entire course on dates and time in R. For our purposes here, we limit the treatment to simple conversion of time and dates as 
textstrings to time and date datatypes that R can understand.


We are going to be using two libraries. 

* Lubridate which is part of tidyverse, but not loaded by default. Lubridate handles a lot of time-related problems.
* zoo which is a very comprehensive library handling many different weird time-related problems.

Install, and load the packages:


~~~
install.packages("lubridate")
install.packages("zoo")
~~~
{: .language-r}


~~~
library(lubridate)
~~~
{: .language-r}



~~~

Attaching package: 'lubridate'
~~~
{: .output}



~~~
The following objects are masked from 'package:base':

    date, intersect, setdiff, union
~~~
{: .output}



~~~
library(zoo)
~~~
{: .language-r}



~~~

Attaching package: 'zoo'
~~~
{: .output}



~~~
The following objects are masked from 'package:base':

    as.Date, as.Date.numeric
~~~
{: .output}


Time and dates as we get them from apis will typically come in a variation of these formats:

yyyy-mm-dd
yyyy-mm-dd hh:mm:ss
mmmyyyy
yyyymmm
yyyyQq

Where yyyy is a year, sometimes with only two digits, mm a month as number, eg 07 for july, dd as a day, eg 22.

mmm covers the special case where eg. jul2022 denotes july 2022, that is not so much a specific date, but a specific month

The same is the case with Qq, where 2022Q1 would denote the first quarter (january 1st to march 31st)

hh is hours, mm minutes and ss seconds. 

And the order of all these elements might be different from data source to data source.

Let us look at some examples, and how to convert them to a consistent format:

Year-month-date:


~~~
ymd("2022-06-20")
~~~
{: .language-r}



~~~
[1] "2022-06-20"
~~~
{: .output}
Month-date-year:

~~~
mdy("06-20-2022")
~~~
{: .language-r}



~~~
[1] "2022-06-20"
~~~
{: .output}
The lubridate functions are pretty smart. Even without hyphenation and with shortened year, they convert correctly:

~~~
mdy("062022")
~~~
{: .language-r}



~~~
[1] "2022-06-20"
~~~
{: .output}
You might have guess the pattern:


~~~
ydm("22-20-6")
~~~
{: .language-r}



~~~
[1] "2022-06-20"
~~~
{: .output}

~~~
myd("062220")
~~~
{: .language-r}



~~~
[1] "2022-06-20"
~~~
{: .output}
En challenge her kunne vÃ¦re fin.

What about time?

given a time:

~~~
"13:10:47"
~~~
{: .language-r}



~~~
[1] "13:10:47"
~~~
{: .output}

Very weird formats of time is not covered:

~~~
ymd_hms("2022-06-20 13:10:47")
~~~
{: .language-r}



~~~
[1] "2022-06-20 13:10:47 UTC"
~~~
{: .output}
as_date(char_dates, format = "%m/%d/%Y")


~~~
as_datetime("2022-06-20 12:14:15 ")
~~~
{: .language-r}



~~~
[1] "2022-06-20 12:14:15 UTC"
~~~
{: .output}
Even if it gets extremely weird, we can access specialised functions:

~~~
parse_date_time("12:20:14:2022:15:06", orders="%H%d%M%Y%S%m")
~~~
{: .language-r}



~~~
[1] "2022-06-20 12:14:15 UTC"
~~~
{: .output}
Read the documentation to get at complete list of codes specifying the order of
time elements.

Specialised times like months and quarters often come from statistical databases:


~~~
as.yearqtr("2022Q2")
~~~
{: .language-r}



~~~
[1] "2022 Q2"
~~~
{: .output}

~~~
zoo::as.yearmon("jan2022")
~~~
{: .language-r}



~~~
[1] "Jan 2022"
~~~
{: .output}
The zoo functions are not qute as smart as the lubridate functions, but we can 
specify the input format like we did with the very weird examples above:

~~~
as.yearmon("2022jan", format="%Y%b")
~~~
{: .language-r}



~~~
[1] "Jan 2022"
~~~
{: .output}

Zoo uses the same codes for specifying elements of dates as lubridate.


{% include links.md %}
